# C 语言编译器实现

[![Language](https://img.shields.io/badge/language-C-blue.svg)]()
[![License](https://img.shields.io/badge/license-MIT-green.svg)]()

一个功能完整的 C 语言子集编译器，实现了从源代码到三地址中间代码的完整编译流程。支持词法分析、语法分析、语义分析和中间代码生成，具有完善的错误检测和报告机制。

## 🎯 项目特色

- ✅ **完整的编译流程**: 词法 → 语法 → 语义 → 中间代码生成
- ✅ **强大的错误检测**: 支持 6 种语义错误类型的精确检测
- ✅ **标准三地址码**: 生成优化友好的中间表示
- ✅ **全面测试覆盖**: 18 个测试用例，100%通过率
- ✅ **模块化设计**: 清晰的架构，易于扩展和维护

## 📋 项目概述

本项目是一个完整的编译器前端实现，包含编译器的四个核心阶段：

- **词法分析 (Lexical Analysis)** - 使用 Flex 生成高效的词法分析器
- **语法分析 (Syntax Analysis)** - 使用 Bison 生成 LALR(1) 语法分析器
- **语义分析 (Semantic Analysis)** - 多层作用域符号表管理和类型检查
- **中间代码生成 (Code Generation)** - 生成标准三地址中间代码

## ✨ 支持的语言特性

### 🔢 数据类型

- **基本类型**: `int`、`float`
- **复合类型**: 一维/多维数组、结构体
- **函数类型**: 支持参数和返回值的函数定义

### 🏗️ 语言构造

- **变量操作**: 声明、定义、赋值
- **函数机制**: 定义、调用、参数传递、返回值
- **算术运算**: `+`、`-`、`*`、`/`、一元`-`
- **关系运算**: `>`、`<`、`>=`、`<=`、`==`、`!=`
- **逻辑运算**: `&&`、`||`、`!`
- **控制流**: `if-else`、`while`、`return`
- **复合结构**: 嵌套控制流、复杂表达式

### 📝 语法示例

```c
// 函数定义和调用
int add(int x, int y) {
    return x + y;
}

// 嵌套控制结构
int main() {
    int i = 1, sum = 0;

    while (i <= 10) {
        if (i % 2 == 0) {
            sum = sum + i;
        }
        i = i + 1;
    }

    int result = add(sum, 100);
    return result;
}
```

## 🏗️ 项目架构

```
📦 编译器项目
├── 🔧 核心模块
│   ├── main.c              # 主控制器和编译流程协调
│   ├── lexer.l             # Flex词法分析器规则定义
│   ├── parser.y            # Bison语法分析器规则定义
│   ├── tree.h/tree.c       # 抽象语法树数据结构与操作
│   ├── semantic.h/semantic.c # 语义分析器和符号表管理
│   └── codegen.h/codegen.c # 三地址代码生成器
├── 📋 规范文档
│   ├── 文法定义.txt         # 完整的BNF语法规范
│   └── Makefile            # 自动化构建配置
├── 🧪 测试框架
│   ├── tests/              # 功能测试用例 (10个)
│   ├── tests/test_error_*  # 错误检测用例 (8个)
│   ├── run_tests.bat       # 自动化测试脚本
│   └── test_results/       # 测试输出结果
└── 📄 文档
    └── README.md           # 项目说明文档
```

## 🔧 环境要求与构建

### 系统要求

- **编译器**: GCC 4.8+ 或 Clang 3.5+
- **构建工具**: GNU Make 3.8+
- **词法生成器**: Flex 2.5+
- **语法生成器**: Bison 3.0+
- **操作系统**: Windows 10+、Linux

### 快速开始

```bash
# 1. 克隆项目
git clone <repository-url>
cd compiler-project

# 2. 构建编译器
make

# 3. 运行测试
./run_tests.bat    # Windows
# 或
chmod +x run_tests.sh && ./run_tests.sh  # Linux/macOS

# 4. 编译源文件
./parser tests/test_05_functions.c
```

### 构建选项

```bash
make              # 构建编译器
make clean        # 清理构建文件
```

## 🚀 使用指南

### 基本用法

```bash
./parser <source_file.c>
```

### 输出说明

编译器会依次输出：

1. **语法树**: 完整的抽象语法树结构
2. **中间代码**: 标准三地址码格式
3. **文件保存**: 中间代码自动保存到 `output.ir`

### 使用示例

```bash
# 编译简单程序
./parser tests/test_01_basic_variables.c

# 编译复杂控制结构
./parser tests/test_10_nested_control.c

# 测试错误检测
./parser tests/test_error_01_undefined_variable.c
```

## 📊 三地址代码格式

### 指令类型

| 类别         | 指令格式            | 说明       |
| ------------ | ------------------- | ---------- |
| **算术运算** | `t1 := a + b`       | 加法运算   |
|              | `t2 := a - b`       | 减法运算   |
|              | `t3 := a * b`       | 乘法运算   |
|              | `t4 := a / b`       | 除法运算   |
| **赋值操作** | `x := y`            | 变量赋值   |
|              | `x := #5`           | 常量赋值   |
| **关系运算** | `t1 := a > b`       | 关系比较   |
| **控制流**   | `IF t1 GOTO label1` | 条件跳转   |
|              | `GOTO label2`       | 无条件跳转 |
|              | `label1 :`          | 标签定义   |
| **函数操作** | `FUNCTION main :`   | 函数开始   |
|              | `PARAM x`           | 参数声明   |
|              | `ARG a`             | 参数传递   |
|              | `t1 := CALL func`   | 函数调用   |
|              | `RETURN x`          | 返回语句   |
|              | `END FUNCTION main` | 函数结束   |

### 代码示例

**源代码**:

```c
int main() {
    int a = 5, b = 10;
    if (a < b) {
        return a + b;
    } else {
        return a - b;
    }
}
```

**生成的三地址代码**:

```
FUNCTION main :
a := #5
b := #10
t1 := a < b
IF t1 GOTO label1
GOTO label2
label1 :
t2 := a + b
RETURN t2
label2 :
t3 := a - b
RETURN t3
END FUNCTION main
```

## 🧪 测试框架

### 功能测试 (10 个测试用例)

| 测试编号 | 测试内容           | 状态    |
| -------- | ------------------ | ------- |
| test_01  | 基本变量声明和赋值 | ✅ 通过 |
| test_02  | 算术运算表达式     | ✅ 通过 |
| test_03  | if-else 条件语句   | ✅ 通过 |
| test_04  | while 循环语句     | ✅ 通过 |
| test_05  | 函数定义和调用     | ✅ 通过 |
| test_06  | 数组操作           | ✅ 通过 |
| test_07  | 结构体操作         | ✅ 通过 |
| test_08  | 复杂表达式计算     | ✅ 通过 |
| test_09  | 逻辑运算           | ✅ 通过 |
| test_10  | 嵌套控制结构       | ✅ 通过 |

### 错误检测测试 (8 个测试用例)

| 错误类型        | 检测内容         | 状态        |
| --------------- | ---------------- | ----------- |
| Error Type 1    | 变量未定义使用   | ✅ 检测正确 |
| Error Type 2    | 函数未定义调用   | ✅ 检测正确 |
| Error Type 3    | 变量重复定义     | ✅ 检测正确 |
| Error Type 4    | 函数重复定义     | ✅ 检测正确 |
| Error Type 5    | 返回类型不匹配   | ✅ 检测正确 |
| Error Type 6    | 函数调用参数错误 | ✅ 检测正确 |
| Multiple Errors | 复合错误检测     | ✅ 检测正确 |
| Control Flow    | 控制流错误       | ✅ 检测正确 |

### 运行测试

```bash
# 运行所有测试
./run_tests.bat

# 运行单个测试
./parser tests/test_05_functions.c

# 查看测试结果
ls test_results/
```

## 📈 项目状态

### ✅ 已完成功能

- [x] **词法分析**: 完整的 token 识别，支持注释过滤
- [x] **语法分析**: LALR(1)分析器，完整 AST 构建
- [x] **语义分析**: 多层作用域符号表，6 种错误类型检测
- [x] **代码生成**: 标准三地址码，支持所有语言构造
- [x] **函数支持**: 完整的函数定义、调用、参数传递
- [x] **控制流**: if-else、while 的完整支持
- [x] **表达式**: 算术、关系、逻辑运算的完整支持
- [x] **错误处理**: 精确的错误定位和报告
- [x] **测试框架**: 18 个测试用例，100%通过率

### 🚧 优化方向

- [ ] **浮点数表示**: 改进中间代码中的浮点数显示格式
- [ ] **数组增强**: 多维数组和数组初始化的完整支持
- [ ] **结构体增强**: 结构体嵌套和复杂操作
- [ ] **错误恢复**: 语法错误后的智能恢复机制
- [ ] **代码优化**: 基本块分析和死代码消除
- [ ] **调试信息**: 生成调试器可用的符号信息

### 🔮 未来规划

- [ ] **后端开发**: x86/ARM 汇编代码生成
- [ ] **优化器**: 循环优化、内联优化
- [ ] **语言扩展**: 指针、函数指针、递归优化
- [ ] **工具集成**: IDE 插件、调试器支持

## 🔍 技术细节

### 编译器架构

```
源代码 (.c) → 词法分析 → Token流 → 语法分析 → AST → 语义分析 → 符号表 → 代码生成 → 三地址码 (.ir)
```

### 核心算法

- **词法分析**: 基于正则表达式的有限状态自动机
- **语法分析**: LALR(1)移进-归约分析算法
- **语义分析**: 递归下降的语义检查
- **代码生成**: 语法制导的翻译方案

### 性能特征

- **时间复杂度**: O(n) 线性时间编译
- **空间复杂度**: O(n) 线性空间使用
- **错误检测**: 单遍扫描多错误检测

## 📚 学习资源

### 相关文档

- `文法定义.txt` - 完整的 BNF 语法规范
- `tests/` - 丰富的示例代码
- `test_results/` - 详细的编译输出示例

### 推荐阅读

- 《编译原理》(龙书) - 理论基础
- 《现代编译器实现》- 实践指导
- Flex & Bison 官方文档 - 工具使用

---

**最后更新**: 2025 年 5 月  
**项目版本**: v1.0
